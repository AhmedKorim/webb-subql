type EdgeAddition @entity(immutable: true) {
  id: ID!
  chainID: BigInt! # uint256
  latestLeafIndex: BigInt! # uint256
  merkleRoot: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EdgeUpdate @entity(immutable: true) {
  id: ID!
  chainID: BigInt! # uint256
  latestLeafIndex: BigInt! # uint256
  merkleRoot: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Insertion @entity(immutable: true) {
  id: ID!
  commitment: BigInt! # uint256
  leafIndex: BigInt! # uint32
  timestamp: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NewCommitment @entity(immutable: true) {
  id: Bytes!
  commitment: BigInt! # uint256
  subTreeIndex: BigInt! # uint256
  leafIndex: BigInt! # uint256
  encryptedOutput: Bytes! # bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NewNullifier @entity(immutable: true) {
  id: ID!
  nullifier: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type PublicKey @entity(immutable: true) {
  id: ID!
  owner: Bytes! # address
  key: Bytes! # bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type TransferTx @entity(immutable: true) {
  id: ID!
  from: Bytes! # addresss
  to: Bytes! # address
  value: BigInt! # uint256
  finalValue: BigInt! # value without fees
  fee: BigInt!

  vAnchor: VAnchor!
  fungibleTokenWrapper: FungibleTokenWrapper!

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  contractAddress: Bytes!
}

type DepositTx @entity(immutable: true) {
  id: ID!
  depositor: Bytes!
  # deposit amount
  value: BigInt! # uint256
  isWrapAndDeposit: Boolean!
  wrappingFee: BigInt!
  RelayerFee: BigInt!
  fullFee: BigInt!
  gasUsed: BigInt!
  finalValue: BigInt! # value without fees
  blockTimestamp: BigInt!
  transactionHash: Bytes!

  vAnchor: VAnchor!
  fungibleTokenWrapper: FungibleTokenWrapper!
  wrappedToken: Token!

  blockNumber: BigInt!
}

type WithdrawTx @entity(immutable: true) {
  id: ID!
  beneficiary: Bytes!
  # deposit amount
  value: BigInt! # uint256
  gasUsed: BigInt!

  isUnwrapAndWithdraw: Boolean!
  unWrappingFee: BigInt!
  RelayerFee: BigInt!
  fullFee: BigInt!

  finalValue: BigInt! # value without fees
  blockTimestamp: BigInt!
  transactionHash: Bytes!

  vAnchor: VAnchor!
  fungibleTokenWrapper: FungibleTokenWrapper!
  wrappedToken: Token!

  blockNumber: BigInt!
}
type VAnchorVolume @entity {
  #<VAnchorId>-<TokenId>
  id: ID!
  #Wrapped Token of the transact call
  token: Token!
  vAnchor: VAnchor!
  valueLocked: BigInt!
  finalValueLocked: BigInt!
  totalFees: BigInt!
  totalWrappingFees: BigInt!
}
type VAnchor @entity(immutable: false) {
  id: ID!
  contractAddress: Bytes!
  chainId: BigInt!
  typedChainId: Bytes!
  token: FungibleTokenWrapper!

  interactedToken: [VAnchorVolume!]!
  # VAnchor locked volume
  valueLocked: BigInt!
  finalValueLocked: BigInt!
  totalFees: BigInt!
  totalWrappingFees: BigInt!

  maxDepositAmount: BigInt!
  minDepositAmount: BigInt!
  numberOfDeposits: BigInt!
  averageDepositAmount: BigInt!

  maxWithdrawAmount: BigInt!
  minWithdrawAmount: BigInt!
  numberOfWithdraws: BigInt!
  averageWithdrawAmount: BigInt!
}
type VAnchorVolumeComposition @entity {
  # <Day index>-<vAnchorAddress>-<token>
  id: ID!

  token: Token!
  VAnchorDayData: VAnchorDayData!

  relayerFees: BigInt!
  wrappingFees: BigInt!
  unWrappingFees: BigInt!

  fees: BigInt!
  volume: BigInt!
}
type VAnchorDayData @entity(immutable: false) {
  # <Day index>-<vAnchorAddress>
  id: ID!
  date: Int!

  vAnchor: VAnchor!
  composition: [VAnchorVolumeComposition!]!

  relayerFees: BigInt!
  wrappingFees: BigInt!
  fees: BigInt!
  volume: BigInt!
  depositedVolume: BigInt!
  withdrawnVolume: BigInt!

  numberOfDeposits: BigInt!
  numberOfWithdraws: BigInt!
  numberOfTransfers: BigInt!

  depositTx: [DepositTx!]!
  withdrawTx: [WithdrawTx!]!
  transferTx: [TransferTx!]!

  startBlockNumber: BigInt!
}
type Deploy @entity(immutable: true) {
  id: ID!
  addr: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Token @entity(immutable: false) {
  id: Bytes!
  address: Bytes!
  isFungibleTokenWrapper: Boolean!
  name: String!
  symbol: String!
  decimals: Int!
}

type FungibleTokenWrapperComposition @entity(immutable: false) {
  #<FTW id>-<Token id>
  id: Bytes!
  token: Token!
  volume: BigInt!
}
type FungibleTokenWrapper @entity(immutable: false) {
  # FungibleTokenWrapper contract address
  id: Bytes!
  name: String!
  # Contract address
  address: Bytes!
  symbol: String!
  # List of underlying tokens (Token that can be wrapped into the FTW, or the FTW can unwrap to)
  tokens: [Token!]!
  # The symbol of one the of the underlying tokens
  baseTokenSymbol: String
  decimals: Int!
  feePercentage: Int!
  composition: [FungibleTokenWrapperComposition!]!
}
